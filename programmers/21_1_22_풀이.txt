#프로그래머스 greedy알고리즘 level 2

sample에는 name의 글자 수만큼 A 집어넣음
sampe 과 temp는 리스트
count 변수 선언(-1부터 시작)


-----전체 for문으로 묶음. why? 글자수만큼 반복시켜야하므로.
다시 반복되는 경우==> 글자수가 남아있고 커서 이동이므로 +1
count +=1
1.temp와 sample의 [i]번째 인덱스를 ord로 변환한다
그 후 두 값의 차이 계산.==> 그 차이많큼 조이스틱 움직여야함
temp의 값이 항상 클테니 temp - sample이 나을듯.

if.알파벳 개수는 26 따라서 차이가 13보다 크면 A에서 B쪽으로 순방향이
아닌 A에서 Z쪽으로 역방향으로 가는 것이 더 빠름.(최솟값)
else. 차이만큼 이동
==>빠져나오면 count =count + 차이값

맨바깥에 return count

++내가 까먹은 케이스가 있었다.
커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)
이 조건이 있었는데 만약 JAZ라는 이름이면 가운데 A는 이미 sample을 통해
완성이므로 커서를 오른쪽으로 이동이 아닌 왼쪽으로 한번의 이동을
하는 것이다.
그 때문에 A가 들어간 이름은 1씩 차이가 났었다.
abcd

==> 내가 짠 코드로는 60점 밖에 나오지 않아서 다른 분의 코드를 참고하여 작성했다.
1. 상하이동 
2. 좌우이동 - while문

각 알파벳에대한 최소 이동값을 리스트에 담고,
while문을 돌면서 answer에 각값을 더하고 0으로 만들어준다.
모든 값이 0이면 빠져나옴
좌우로 이동방향을 정할 때 바꿔야하는 알파벳이 나오기까지의 가장 짧은거리 구함.
왼쪽,오른쪽 비교해서 작은값으로 





프로그래머스 Summer/Winter Coding(~2018) - 소수 만들기
------------------------------------------------------------------
논리:
각 원소의 크기가 1000까지라서 완전탐색으로 풀었다.
combinations로 모든 조합 구하고, for문을 돌려서 직접 나누는데 
나누어 떨어지는게 하나 즉, 자기자신 밖에없으면 소수이므로 answer +1 해줌




프로그래머스 연습문제 - 땅따먹기
--------------------------------------------------------------------
동적 계획법 사용
dp[i][0] = max(dp[i+1][1],dp[i+1][2],dp[i+1][3]) + land[i][0]