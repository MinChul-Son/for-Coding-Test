#프로그래머스 greedy알고리즘 level 2

sample에는 name의 글자 수만큼 A 집어넣음
sampe 과 temp는 리스트
count 변수 선언(-1부터 시작)


-----전체 for문으로 묶음. why? 글자수만큼 반복시켜야하므로.
다시 반복되는 경우==> 글자수가 남아있고 커서 이동이므로 +1
count +=1
1.temp와 sample의 [i]번째 인덱스를 ord로 변환한다
그 후 두 값의 차이 계산.==> 그 차이많큼 조이스틱 움직여야함
temp의 값이 항상 클테니 temp - sample이 나을듯.

if.알파벳 개수는 26 따라서 차이가 13보다 크면 A에서 B쪽으로 순방향이
아닌 A에서 Z쪽으로 역방향으로 가는 것이 더 빠름.(최솟값)
else. 차이만큼 이동
==>빠져나오면 count =count + 차이값

맨바깥에 return count

++내가 까먹은 케이스가 있었다.
커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)
이 조건이 있었는데 만약 JAZ라는 이름이면 가운데 A는 이미 sample을 통해
완성이므로 커서를 오른쪽으로 이동이 아닌 왼쪽으로 한번의 이동을
하는 것이다.
그 때문에 A가 들어간 이름은 1씩 차이가 났었다.
abcd

==> 내가 짠 코드로는 60점 밖에 나오지 않아서 다른 분의 코드를 참고하여 작성했다.
1. 상하이동 
2. 좌우이동 - while문

각 알파벳에대한 최소 이동값을 리스트에 담고,
while문을 돌면서 answer에 각값을 더하고 0으로 만들어준다.
모든 값이 0이면 빠져나옴
좌우로 이동방향을 정할 때 바꿔야하는 알파벳이 나오기까지의 가장 짧은거리 구함.
왼쪽,오른쪽 비교해서 작은값으로 





프로그래머스 Summer/Winter Coding(~2018) - 소수 만들기
------------------------------------------------------------------
논리:
각 원소의 크기가 1000까지라서 완전탐색으로 풀었다.
combinations로 모든 조합 구하고, for문을 돌려서 직접 나누는데 
나누어 떨어지는게 하나 즉, 자기자신 밖에없으면 소수이므로 answer +1 해줌




프로그래머스 연습문제 - 땅따먹기
--------------------------------------------------------------------
동적 계획법 사용
열은 4개로 고정되어있으니까 직접 값을 적어줌
dp[i][0] = max(dp[i-1][1],dp[i-1][2],dp[i-1][3]) + land[i][0]
==> 상위행의 같은 열을 제외한 값의 최대값과 현재 땅의 값을
    더하여 dp[i][0] 값으로 갱신해줌
    이런식을 끝까지 내려온 후에 맨 끝행에서의 max값이 우리가 구하려는
    점수의 최대값이다.




프로그래머스 찾아라 프로그래밍 마에스터 > 폰켓몬
-----------------------------------------------------------------
논리:
combinations로 모든 조합만들고, 모든 조합 리스트를 for문을 돌린다.
각 조합을 set에 담아 중복을 제거한다. 중복을 제거한 조합의 길이가
전체배열의 절반(len(nums)//2) 보다 크면 바로 len(nums)//2를 리턴하고
else면 answer에 담아 그 중 max값을 반환하면 된다.
만약 nums = [1,1,2,3,4,6] 이라면 3마리의 폰켓몬을 골라야한다.
nums를 중복제거하면 {1,2,3,4,6} 5종류의 폰켓몬이 있다는 뜻이다.
이것은 내가 골라야할 폰켓몬 수(3마리) 보다 종류의 수가 많으므로
무조건 가장 많이 고를 수 있는 종류는 3종류이다.

그렇지 않고, 만약 nums =[1,1,1,2,2,2] 이라면 역시 3마리를 골라야한다.
중복제거하면 {1,2}인데 2종류의 폰켓몬이 있다는 뜻이다.
내가 골라야할 폰켓몬 수 (3마리) 보다 종류의 수가 적으므로
고를 수 있는 최대 종류 수는 2마리이다. 즉 집합의 len를 반환하면 된다.


==> 제출해보니 시간초과가 떴다. 왜그런지 생각해보니 내가 생각한 논리는 맞았음
    하지만 굳이 조합을 만들어줄 필요가없다. 그냥 주어진 nums리스트를
    중복제거하고 nums//2와 비교하여 return시켜주면 된다.

    



프로그래머스 Summer/Winter Coding(~2018) - 점프와 순간 이동
-----------------------------------------------------------------
논리:
문제를 쪼갤 수 있을 것같다.
짝수라면 2로 나누어떨어지지 않을 때 까지 나누어서 해결해도 동일하다.
n이 6이나 3이나 똑같다는 의미 ==> 어차피 3에서 순간이동하면 6이니까

머리로 생각을 해보니까 그냥 2진수를 구하는 것과 똑같다..
점프 ==> 1
순간이동 ==> 0
5을 이진수로 나타내면 101 ==> 1칸 점프 순간이동 1칸점프
1의 개수를 구하면 되지않을까?
 