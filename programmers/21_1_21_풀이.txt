프로그래머스 연습문제 level2 - 숫자의 표현
--------------------------------------------------------------------
논리:
단순하게 생각했다. 
이중 for문을 돌리는데 외부 for문은 1부터 n//2+1이 범위이다.
이유는 절반을 넘어가면 더하여 원래 값을 만들어 낼 수 없기 때문이다.
예를들어, 15라면 8을 넘어가면 더해서 만들수있는 숫자가 7밖에없다.
즉 이후는 검사할 필요가 없음.
내부 for문의 범위는 i부터 n+1인데 내부 for문은 더하기 시작할 값을 의미한다.
예로 i = 4 라면 j의 범위는 (4,16)이 되는데
내부for문을 수행하면서 count에 j를 더해서 넣어준다.
즉 4 + 5 + 6 처럼 1씩 증가하는 j값을 count와 더하고 이를
if문을 통해 주어진 n과 비교하여 같다면 정답을 +1해주고 break한다.
이렇게하고 제출했더니 효율성에서 실패했다.
이유를 생각해보니. 만약 count가 n보다 커질 때의 조건 즉, else를 정의해줘야한다.
그렇지 않으면 이미 count가 n보다 큼에도 계속해서 for문은 돌아가기 때문이다.
elif로 count > n보다 크면 break하도록 하고 제출하니 통과했다.


++정답이 1부터 시작하는 것은 모든 숫자는 자기 그자체로
표현할 수있는 경우를 미리 더해준 것이다.
1 + 2 + 3 + 4 + 5 = 15
4 + 5 + 6 = 15
7 + 8 = 15
15 = 15
여기서 맨마지막 경우 자기 그자체를 의미한다.




프로그래머스 연습문제 level2 - JadenCase 문자열 만들기
-------------------------------------------------------------------
논리:
먼저 공백을 기준으로 나누어 answer에 담는다.
for문을 통해 answer리스트의 요소를 하나씩 가져오는데 enumerate를 통해
인덱스 값도 같이 가져온다.
슬라이싱을 통해 첫번째 문자가 알파벳이면:
    첫번째 글자를 대문자로 나머지를 소문자로 바꿔줌.
    첫번째 글자 p[:1], 첫번째를 제외한 나머지글자 p[1:]
알파벳이 아니라면:
    첫번째 글자를 그대로 두고 나머지를 소문자로 바꿔줌.

마지막에는 문자열로 다시 합쳐줘야하는데 " ".join을 해줌으로써
단어 사이에 공백을 추가해줌.


++ s.title()이라는 함수를 쓰면 각 단어의 첫글자만 대문자로 나머지는
소문자로 돌려준다.. ㅋㅋㅋ 이런 내장함수도 있네 ;





프로그래머스 연습문제 level2 - 영어 끝말잇기
---------------------------------------------------------------------
논리:
words를  for문을 돌림
만약 인덱스+1을 n으로 나눈게 1이면 한바퀴 돈 것이므로 cycle +1
예로, 3명에서 진행 할때 인덱스가 1, 4 ,7 일때 한바퀴씩 돈다는 의미.
먼저 used 이전에 말한 단어인지를 확인한다. count함수를 통해
used에 있는지 없는지 판단.
있으면
    for문 빠져나오고 틀린사람과 cycle을 answer에 담아 리턴
    for문-else문을 사용해 주어진 단어로만으로는 탈락자가 발생하지 않습니다라는
    케이스를 판별
없으면
    used리스트에 담아줄 건데 그전에 확인해야할 케이스가 끝말잇기의 룰을
    따르고 있는지 확인해야한다 앞사람의 끝단어를 가져와 현재의 첫단어와
    같은지 비교한다. 이것은 슬라이싱을 통하여 구현하였다.


if 문의 개수를 하나로 줄여 한번에 처리할 수도 있을 것 같다.


