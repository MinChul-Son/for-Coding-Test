프로그래머스 연습문제 level2 - 숫자의 표현
--------------------------------------------------------------------
논리:
단순하게 생각했다. 
이중 for문을 돌리는데 외부 for문은 1부터 n//2+1이 범위이다.
이유는 절반을 넘어가면 더하여 원래 값을 만들어 낼 수 없기 때문이다.
예를들어, 15라면 8을 넘어가면 더해서 만들수있는 숫자가 7밖에없다.
즉 이후는 검사할 필요가 없음.
내부 for문의 범위는 i부터 n+1인데 내부 for문은 더하기 시작할 값을 의미한다.
예로 i = 4 라면 j의 범위는 (4,16)이 되는데
내부for문을 수행하면서 count에 j를 더해서 넣어준다.
즉 4 + 5 + 6 처럼 1씩 증가하는 j값을 count와 더하고 이를
if문을 통해 주어진 n과 비교하여 같다면 정답을 +1해주고 break한다.
이렇게하고 제출했더니 효율성에서 실패했다.
이유를 생각해보니. 만약 count가 n보다 커질 때의 조건 즉, else를 정의해줘야한다.
그렇지 않으면 이미 count가 n보다 큼에도 계속해서 for문은 돌아가기 때문이다.
elif로 count > n보다 크면 break하도록 하고 제출하니 통과했다.


++정답이 1부터 시작하는 것은 모든 숫자는 자기 그자체로
표현할 수있는 경우를 미리 더해준 것이다.
1 + 2 + 3 + 4 + 5 = 15
4 + 5 + 6 = 15
7 + 8 = 15
15 = 15
여기서 맨마지막 경우 자기 그자체를 의미한다.




프로그래머스 연습문제 level2 - JadenCase 문자열 만들기
-------------------------------------------------------------------
논리:
먼저 공백을 기준으로 나누어 answer에 담는다.
for문을 통해 answer리스트의 요소를 하나씩 가져오는데 enumerate를 통해
인덱스 값도 같이 가져온다.
슬라이싱을 통해 첫번째 문자가 알파벳이면:
    첫번째 글자를 대문자로 나머지를 소문자로 바꿔줌.
    첫번째 글자 p[:1], 첫번째를 제외한 나머지글자 p[1:]
알파벳이 아니라면:
    첫번째 글자를 그대로 두고 나머지를 소문자로 바꿔줌.

마지막에는 문자열로 다시 합쳐줘야하는데 " ".join을 해줌으로써
단어 사이에 공백을 추가해줌.


++ s.title()이라는 함수를 쓰면 각 단어의 첫글자만 대문자로 나머지는
소문자로 돌려준다.. ㅋㅋㅋ 이런 내장함수도 있네 ;





프로그래머스 연습문제 level2 - 영어 끝말잇기
---------------------------------------------------------------------
논리:
words를  for문을 돌림
만약 인덱스+1을 n으로 나눈게 1이면 한바퀴 돈 것이므로 cycle +1
예로, 3명에서 진행 할때 인덱스가 1, 4 ,7 일때 한바퀴씩 돈다는 의미.
먼저 used 이전에 말한 단어인지를 확인한다. count함수를 통해
used에 있는지 없는지 판단.
있으면
    for문 빠져나오고 틀린사람과 cycle을 answer에 담아 리턴
    for문-else문을 사용해 주어진 단어로만으로는 탈락자가 발생하지 않습니다라는
    케이스를 판별
없으면
    used리스트에 담아줄 건데 그전에 확인해야할 케이스가 끝말잇기의 룰을
    따르고 있는지 확인해야한다 앞사람의 끝단어를 가져와 현재의 첫단어와
    같은지 비교한다. 이것은 슬라이싱을 통하여 구현하였다.


if 문의 개수를 하나로 줄여 한번에 처리할 수도 있을 것 같다.






프로그래머스 연습문제 level 2 - 가장 큰 정사각형 찾기
------------------------------------------------------------------
논리:
삼중 for문을 사용하여 구현을 하긴 했지만, 효율성부분에서 실패했다.
한시간정도 고민을 해보다가 다른 분의 풀이를 찾아보았다.

먼저, 이 문제에서 사용된 개념은 동적 계획법(DP:Dynamic Programming)을 
사용하여야 한다.

동적 계획법이란
복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법을 말한다. 이것은 부분 문제 반복과 최적 부분 구조를 가지고 있는 알고리즘을 일반적인 방법에 비해 더욱 적은 시간 내에 풀 때 사용한다.
분할정복순환과 비슷한 개념이지만 다른점이 있다. 분할정복순환은 중복이 발생하지 않지만
동적 계획법은 중복이 발생하므로 메모이제이션(memoization) 기법을 사용하여야 한다.
메모이제이션이란
    메모이제이션(memoization)은 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술이다. 동적 계획법의 핵심이 되는 기술이다

1   1    ==> 왼쪽과 같이 구성되어 있다면 오른쪽아래 즉 (2,2)가 1일때 왼쪽위 (1,1), 위(1,2), 왼쪽(2,1) 중의 최소값에 1을 더한 것으로
1   1        기준 좌표 (2,2)의 값을 변경해준다.

1   1    ==> 변경 후에는 좌측과 같이 변경될 것이다. 이렇게 이중for문을 통해 수행해가며 문제를 작은 문제로 쪼개어 해결한다.
1   2 

마지막에는 모든 값들 중 max값을 반환해주면 되는데 여기서 사용한 itertools.chain 함수는 인자의 값들을 하나로 합쳐주는 함수이다.
chain('ABC', 'DEF') --> A B C D E F
*board와 같이 *를 붙혀 2차원 리스트 또한 하나로 합칠 수 있다.